---
title: "DATA 589 Project"
author: "Christopher Mulya | Natalie Coutinho | Pranav Kumar Mahesh"
date: "2024-04-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load required packages
suppressWarnings({
  library(sp)
  library(sf)
  library(spatstat)
  library(maptools)
})

# Import the BC Covariates dataset
suppressWarnings({
  load("BC_Covariates.Rda")
})

library(readxl)

# Read the Excel file
suppressWarnings({
  df <- read_excel("Moose_data.xlsx")
})

# Extract decimalLatitude and decimalLongitude columns
latitude_column <- df$decimalLatitude
longitude_column <- df$decimalLongitude
province <- df$stateProvince

# Create a new data frame with latitude and longitude columns
coordinates_df <- data.frame(province = province, latitude = latitude_column, longitude = longitude_column)

# Load the required library
suppressWarnings({
  library(dplyr)
})

# Filter coordinates_df to only include observations from British Columbia (BC)
coordinates <- coordinates_df %>%
  filter(province == "British Columbia" | province == "Bc" | province == "Canada - British Columbia (BC)")


coordinates <- na.omit(coordinates)

# Print the filtered data frame for verification
head(coordinates)
```

```{r}
# Identify the class of each element within the list
sapply(DATA, class)
```

```{r}
# Extracting each element from DATA
Forest <- DATA$Forest
Window <- DATA$Window
Elevation <- DATA$Elevation
HFI <- DATA$HFI
Dist_Water <- DATA$Dist_Water
```

```{r}
# Plot latitude and longitude coordinates
plot(coordinates$longitude, coordinates$latitude, 
     xlab = "Longitude", ylab = "Latitude",
     main = "Scatter Plot of Latitude and Longitude")
```


```{r}
# Create a SpatialPoints object from latitude and longitude coordinates
coordinates_sp <- SpatialPoints(coords = coordinates[, c("longitude", "latitude")], 
                                proj4string = CRS("+proj=longlat +datum=WGS84"))

# Define the BC Albers projection
bc_albers_proj <- CRS("+proj=aea +lat_0=45 +lon_0=-126 +lat_1=50 +lat_2=58.5 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs")

# Transform the coordinates to BC Albers projection
coordinates_bc_albers <- spTransform(coordinates_sp, bc_albers_proj)

# Plot the transformed coordinates
plot(coordinates_bc_albers, 
     xlab = "BC Albers Easting (m)", ylab = "BC Albers Northing (m)",
     main = "BC Albers - Projection of Latitude and Longitude Coordinates")
```

```{r}
# Extract coordinates from the spatial object
coords <- coordinates(coordinates_bc_albers)

# Convert the coordinates to a dataframe
coordinates_df <- as.data.frame(coords)

# Remove duplicate points from the dataframe
coordinates_unique <- unique(coordinates_df)

# Extract x and y coordinates
x_coords <- coordinates_unique$coords.x1
y_coords <- coordinates_unique$coords.x2

# Create the window object
win <- as.owin(Window)

# Check which points are inside the window
inside_window <- inside.owin(x_coords, y_coords, win)

# Subset the coordinates dataframe to keep only the points inside the window
coordinates_inside_window <- coordinates_unique[inside_window, ]

# Convert the unique dataframe back to a spatial object
coordinates_bc_albers <- SpatialPoints(coordinates_inside_window, proj4string = CRS(proj4string(coordinates_bc_albers)))
```

```{r}
# Convert the data to a ppp object using the provided Window object
loc_ppp <- ppp(coordinates_bc_albers@coords[,1], coordinates_bc_albers@coords[,2], window = win)

# Plot the ppp object
plot(loc_ppp, pch = 19, cex = 0.5, main = "Spatial Distribution of Moose")
```
## First Moment Descriptive Statistics:

```{r}
# Rescale the window to a specific unit (kilometer from meter)
rescaled_win <- rescale(win, 1000, unitname = "km") 

# Calculate the intensity of mooses per square kilometer
intensity_moose_km2 <- npoints(loc_ppp) / area(rescaled_win)

# Print the result
print(intensity_moose_km2)
```

```{r}
# Split the moose locations into a 10 by 10 quadrat and count points
Q <- quadratcount(loc_ppp,
                  nx = 10,
                  ny = 10)

#Quadrat test of homogeneity 
quadrat.test(Q)
```
Based on the quadrat test, we can see that the assumption of homogeneity is violated (small p-value)

```{r}
# Plot the moose locations and quadrats
plot(loc_ppp,
     pch = 16,
     cex = 0.5,
     cols = "#046C9A",
     main = "Spatial Distribution of Moose")
plot(Q, cex = 1, col = "red", add = TRUE)
```
```{r}
# Plot the quadrat intensity
plot(intensity(Q, image = TRUE),
     main = "Quadrat Intensity of Moose")

# Plot the park locations
plot(loc_ppp,
     pch = 16,
     cex = 0.6,
     col = "white",
     add = TRUE)

plot(loc_ppp,
     pch = 16,
     cex = 0.5,
     col = "black",
     add = TRUE)
```

```{r}
# Compute the kernel density estimate
density_map <- density.ppp(loc_ppp)

# Plot the kernel density estimate
plot(density_map, main = "Kernel Density Estimate of Moose Spatial Distribution")

# Add points to the plot (white circles with black border)
plot(loc_ppp, pch = 19, cex = 0.8, add = TRUE)
plot(loc_ppp, pch = 19, cex = 0.5, cols="white", add = TRUE)
```
From the kernel estimation above, we can see that our data is inhomogeneous, with higher intensity (lambda(u)) in the lower side of the observation window.

## Second Moment Statistics

#### Ripley's K-function
```{r}
# Compute Ripley's K-function corrected for inhomogeneity
K_inhom <- Kinhom(loc_ppp)

# Plot Ripley's K-function corrected for inhomogeneity
plot(K_inhom, main = "Ripley's K-function Corrected for Inhomogeneity")
```
#### g-function
```{r}
# Compute the pair correlation function (g function)
g_func <- pcf(loc_ppp)

# Plot the pair correlation function
plot(g_func, theo ~ r, ylim = c(0, 25), main = "", col = "grey70", lty = "dashed")
plot(g_func, iso ~ r, col = "#046C9A", add = TRUE)
```


```{r}
# Plot the owin object
plot(Window, main = "Observation Window")
```
```{r}
plot(Forest)
```

```{r}
plot(HFI)
```
```{r}
plot(Dist_Water)
```

